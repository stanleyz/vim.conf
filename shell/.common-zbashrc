# Vi mode bash key bindings
#stty -ixon
#set -o vi
#bind '"\C-a": beginning-of-line'
#bind '"\C-e": end-of-line'
#Bind '"\C-k": kill-line'
#bind '"\C-p": previous-history'
#bind '"\C-n": next-history'
#bind '"\C-l": clear-screen'
#bind '"\C-w": backward-kill-word'

# Fall back to emacs mode now
set -o emacs

# alias -----------------------------------------------------------------------
alias grep='grep --color'
# Interprate color
alias less='less -R'
alias xda='tmux detach -a'
alias sudo='sudo -E '
alias cddl='cd ~/Downloads'
alias emacs='emacs -nw'
alias xs='tmux-cssh'
alias vboxm="VBoxManage"
alias vml="VBoxManage list vms"
alias vmlr="VBoxManage list runningvms"
#alias vim='nvim'
alias kg='kubectl get'
alias kgy='kubectl get -oyaml'
alias kga='kubectl get -A'
alias ke='kubectl edit'
alias kd='kubectl describe'
alias kns='kubectl-ns'
alias kx=kubectx
alias h=helm
alias v=nvim
alias k=kubectl
alias f=flux
#alias fg='flux get'
alias a=assume
alias ac="assume -c --bp Default"

# general export --------------------------------------------------------------
export EDITOR='nvim'

# less colors -----------------------------------------------------------------
export LESS_TERMCAP_mb=$'\E[01;31m'       # begin blinking
export LESS_TERMCAP_md=$'\E[01;38;5;74m'  # begin bold
export LESS_TERMCAP_me=$'\E[0m'           # end mode
export LESS_TERMCAP_se=$'\E[0m'           # end standout-mode
export LESS_TERMCAP_so=$'\E[38;5;016m\E[48;5;220m'    # begin standout-mode - info box
export LESS_TERMCAP_ue=$'\E[0m'           # end underline
export LESS_TERMCAP_us=$'\E[04;38;5;146m' # begin underline

# Bash history ----------------------------------------------------------------
export HISTCONTROL=ignoreboth:erasedups  # no duplicate entries
export HISTSIZE=100000                   # big big history
export HISTFILESIZE=100000               # big big history
export HISTTIMEFORMAT="%d/%m/%y %T "

# Save and reload the history after each command finishes
export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

# FZF settings ----------------------------------------------------------------
# Use ~~ as the trigger sequence instead of the default ..
export FZF_COMPLETION_TRIGGER='..'
# Options to fzf command
export FZF_COMPLETION_OPTS='+c -x'

# Use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
  fd --hidden --follow --exclude ".git" . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
  fd --type d --hidden --follow --exclude ".git" . "$1"
}

# Include ~/bin if it's not in the PATH variable
#[[ "$PATH" == *~/.local/bin* ]] || export PATH="~/.local/bin:$PATH"

# Virtualenvwrapper
# load virtualenvwrapper for python (after custom PATHs)
venvwrap="virtualenvwrapper.sh"
/usr/bin/which $venvwrap > /dev/null 2>&1
if [ $? -eq 0 ]; then
    venvwrap=`/usr/bin/which $venvwrap`
    source $venvwrap
fi

# Platform specific settings --------------------------------------------------
platform=$(uname)
case $platform in 
  Darwin)
    alias ls='ls -G'
    alias ftpup='sudo -s launchctl load -w /System/Library/LaunchDaemons/ftp.plist'
    alias ftpdown='sudo -s launchctl unload -w /System/Library/LaunchDaemons/ftp.plist'

    export DYLD_LIBRARY_PATH=/usr/local/mysql/lib

    if [ `ps aux |grep ssh-agent | grep -v grep | wc -l` -lt 1 ]; then
      eval `ssh-agent -s` > /dev/null
    fi
    ssh-add > /dev/null 2>&1

    ;;
  Linux)
    alias ls='ls --color'
    alias docker='sudo docker'
    ;;
esac

# functions -------------------------------------------------------------------
# VNC via ssh tunnel
vnc5901via22() {
  if [ "X$(netstat -an | grep 127.0.0.1.5901)" != "X" ]; then
    echo "Already binded"
    return 1
  fi
  ssh -N -T -L 5901:localhost:5901 $1 &
}
# Git
gdbranch() {
  branch=$1
  
  git push origin --delete $branch
  git branch -D $branch
}
# Docker
rac() {
  docker rm $(docker ps -a | grep -v CONTAINER | grep -v _keep | awk '{print $1}')
}
rai() {
  docker rmi $(docker images | grep '<none>' | awk '{print $3}')
}
dockerunbash() { 
  host_name=$3
  c_name=$2
  i_name=$1
  cmd="docker run -ti"
  if [[ "X$c_name" != "X" ]]; then
    cmd="$cmd --name='$c_name'"
  fi
  if [[ "X$host_name" != "X" ]]; then
    cmd="$cmd -h $host_name"
  fi
  cmd="$cmd $i_name /bin/bash"
  $cmd
}

doexecbash() {
  c_id=$1
  docker exec -ti $c_id /bin/bash --login
}

sshkeyrm() {
  ssh-keygen -f ~/.ssh/known_hosts -R $1
}

vms () { 
  VBoxHeadless -s $1 -v off & 
  i=0
  while [ $i -lt 60 ]; do
    ip=$(VBoxManage guestproperty enumerate $1 | grep -i ip)
    if [[ "X$ip" == "X" ]]; then
      echo "Starting..."
      sleep 2
      i=$((i+2))
    else
      echo $ip
      break
    fi
  done 
}
vmip() {
  VBoxManage guestproperty enumerate $1 |grep -i ip
}
vmd () { VBoxManage controlvm $1 $2; }
vmrdp () { VBoxManage controlvm $1 vrde $2; }
xopen () { cd ~/Documents/xopen/$1; }

xfolder() {
  if [ $# -lt 1 ]; then
    echo "I need a host to work on..."
    exit 1
  fi
  # make the first hostname as a template to compare with other hostnames
  first_hostname=$1
  shift
  ts_name=""
  # Compare character by character with the first argument.
  for j in $(seq 0 ${#first_hostname})
  do
    for i in $*
    do
      common_char=${first_hostname:$j:1}
      if [ "X${i:$j:1}" != "X$common_char" ]; then
        common_char="_"
        break
      fi
    done
    ts_name="${ts_name}${common_char}"
  done

  if [ -z ${ts_name} ]; then
    if [[ -z ${first_hostname} ]]; then
      ts_name="unknown_name_$RANDOM"
    else
      ts_name=$first_hostname
    fi
  else
    ts_name=$(echo $ts_name | sed 's/[@.]/_/g')
  fi
  tmux-cfolder -ts ${ts_name} $first_hostname $*
}

hostx() {
  if [[ $# -lt 2 ]]; then
    echo "No enough parameters provided!"
    return 1
  fi
  host=$1
  srv=""
  shift
  for i in $*
  do
    range=$(echo $i | sed 's/\.\./\^/')
    start=${range%^*} 
    stop=${range#*^} 
    for j in $(seq $start $stop)
    do
      host $(echo $host | sed s/?/$j/) 
    done
  done
}


xsh() {
  if [ $# -lt 1 ]; then
    echo "I need a host to work on..."
    exit 1
  fi
  # make the first hostname as a template to compare with other hostnames
  first_hostname=$1
  shift
  ts_name=""
  # Compare character by character with the first argument.
  for j in $(seq 0 ${#first_hostname})
  do
    for i in $*
    do
      common_char=${first_hostname:$j:1}
      if [ "X${i:$j:1}" != "X$common_char" ]; then
        common_char="_"
        break
      fi
    done
    ts_name="${ts_name}${common_char}"
  done

  if [ -z ${ts_name} ]; then
    if [[ -z ${first_hostname} ]]; then
      ts_name="unknown_name_$RANDOM"
    else
      ts_name=$first_hostname
    fi
  else
    ts_name=$(echo $ts_name | sed 's/[@.]/_/g')
  fi
  tmux-cssh -ts ${ts_name} $first_hostname $*
}

hostx() {
  if [[ $# -lt 2 ]]; then
    echo "No enough parameters provided!"
    return 1
  fi
  host=$1
  srv=""
  shift
  for i in $*
  do
    range=$(echo $i | sed 's/\.\./\^/')
    start=${range%^*} 
    stop=${range#*^} 
    for j in $(seq $start $stop)
    do
      host $(echo $host | sed s/?/$j/) 
    done
  done
}

msr() {
  if [[ "X$#" != "X1" ]]; then
    echo "One and only one param needed"
    return 1
  fi
  host=$1
  mosh $1 -- /bin/bash -c "tmux at || tmux"
}

ssr() {
  if [[ "X$#" != "X1" ]]; then
    echo "One and only one param needed"
    return 1
  fi
  host=$1
  ssh $1 -t "tmux at || tmux"
}
function x() {
  if [[ $# -gt 0 ]]; then
    tmux $@
  else
    tmux at || tmux
  fi
}

fix_docker_host_sock() {
  export DOCKER_HOST=unix:///Users/$USER/.docker/run/docker.sock
  sudo ln -sf /Users/$USER/.docker/run/docker.sock /var/run/docker.sock
  export TESTCONTAINERS_DOCKER_SOCKET_OVERRIDE=/var/run/docker.sock
}
